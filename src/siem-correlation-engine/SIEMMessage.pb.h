// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SIEMMessage.proto

#ifndef PROTOBUF_SIEMMessage_2eproto__INCLUDED
#define PROTOBUF_SIEMMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace SIEM {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SIEMMessage_2eproto();
void protobuf_AssignDesc_SIEMMessage_2eproto();
void protobuf_ShutdownFile_SIEMMessage_2eproto();

class SIEMPbMessage;
class SIEMPbMessage_SIEMPbEvent;

enum SIEMPbMessage_SIEMProtocolType {
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_NONE = -1,
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_ICMP = 1,
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_TCP = 6,
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_UDP = 17,
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_ARP_EVENT = 134,
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_OS_EVENT = 135,
  SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_SERVER_EVENT = 136
};
bool SIEMPbMessage_SIEMProtocolType_IsValid(int value);
const SIEMPbMessage_SIEMProtocolType SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_MIN = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_NONE;
const SIEMPbMessage_SIEMProtocolType SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_MAX = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_SERVER_EVENT;
const int SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_ARRAYSIZE = SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_MAX + 1;

enum SIEMPbMessage_SIEMEventType {
  SIEMPbMessage_SIEMEventType_SIEM_EVENT_NONE = -1,
  SIEMPbMessage_SIEMEventType_SIEM_EVENT_DETECTOR = 1,
  SIEMPbMessage_SIEMEventType_SIEM_EVENT_MONITOR = 2,
  SIEMPbMessage_SIEMEventType_SIEM_EVENT_BACKLOG = 3
};
bool SIEMPbMessage_SIEMEventType_IsValid(int value);
const SIEMPbMessage_SIEMEventType SIEMPbMessage_SIEMEventType_SIEMEventType_MIN = SIEMPbMessage_SIEMEventType_SIEM_EVENT_NONE;
const SIEMPbMessage_SIEMEventType SIEMPbMessage_SIEMEventType_SIEMEventType_MAX = SIEMPbMessage_SIEMEventType_SIEM_EVENT_BACKLOG;
const int SIEMPbMessage_SIEMEventType_SIEMEventType_ARRAYSIZE = SIEMPbMessage_SIEMEventType_SIEMEventType_MAX + 1;

// ===================================================================

class SIEMPbMessage_SIEMPbEvent : public ::google::protobuf::MessageLite {
 public:
  SIEMPbMessage_SIEMPbEvent();
  virtual ~SIEMPbMessage_SIEMPbEvent();

  SIEMPbMessage_SIEMPbEvent(const SIEMPbMessage_SIEMPbEvent& from);

  inline SIEMPbMessage_SIEMPbEvent& operator=(const SIEMPbMessage_SIEMPbEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const SIEMPbMessage_SIEMPbEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SIEMPbMessage_SIEMPbEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SIEMPbMessage_SIEMPbEvent* other);

  // implements Message ----------------------------------------------

  SIEMPbMessage_SIEMPbEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SIEMPbMessage_SIEMPbEvent& from);
  void MergeFrom(const SIEMPbMessage_SIEMPbEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 plugin_id_uint32 = 1;
  inline bool has_plugin_id_uint32() const;
  inline void clear_plugin_id_uint32();
  static const int kPluginIdUint32FieldNumber = 1;
  inline ::google::protobuf::uint32 plugin_id_uint32() const;
  inline void set_plugin_id_uint32(::google::protobuf::uint32 value);

  // required uint32 plugin_sid_uint32 = 2;
  inline bool has_plugin_sid_uint32() const;
  inline void clear_plugin_sid_uint32();
  static const int kPluginSidUint32FieldNumber = 2;
  inline ::google::protobuf::uint32 plugin_sid_uint32() const;
  inline void set_plugin_sid_uint32(::google::protobuf::uint32 value);

  // required uint32 data_uint32 = 3;
  inline bool has_data_uint32() const;
  inline void clear_data_uint32();
  static const int kDataUint32FieldNumber = 3;
  inline ::google::protobuf::uint32 data_uint32() const;
  inline void set_data_uint32(::google::protobuf::uint32 value);

  // required uint32 fdata_uint32 = 4;
  inline bool has_fdata_uint32() const;
  inline void clear_fdata_uint32();
  static const int kFdataUint32FieldNumber = 4;
  inline ::google::protobuf::uint32 fdata_uint32() const;
  inline void set_fdata_uint32(::google::protobuf::uint32 value);

  // required .SIEM.SIEMPbMessage.SIEMEventType event_type_enum = 5;
  inline bool has_event_type_enum() const;
  inline void clear_event_type_enum();
  static const int kEventTypeEnumFieldNumber = 5;
  inline ::SIEM::SIEMPbMessage_SIEMEventType event_type_enum() const;
  inline void set_event_type_enum(::SIEM::SIEMPbMessage_SIEMEventType value);

  // required uint32 src_ipv4_uint32 = 6;
  inline bool has_src_ipv4_uint32() const;
  inline void clear_src_ipv4_uint32();
  static const int kSrcIpv4Uint32FieldNumber = 6;
  inline ::google::protobuf::uint32 src_ipv4_uint32() const;
  inline void set_src_ipv4_uint32(::google::protobuf::uint32 value);

  // required uint32 dst_ipv4_uint32 = 7;
  inline bool has_dst_ipv4_uint32() const;
  inline void clear_dst_ipv4_uint32();
  static const int kDstIpv4Uint32FieldNumber = 7;
  inline ::google::protobuf::uint32 dst_ipv4_uint32() const;
  inline void set_dst_ipv4_uint32(::google::protobuf::uint32 value);

  // required uint32 device_ipv4_uint32 = 8;
  inline bool has_device_ipv4_uint32() const;
  inline void clear_device_ipv4_uint32();
  static const int kDeviceIpv4Uint32FieldNumber = 8;
  inline ::google::protobuf::uint32 device_ipv4_uint32() const;
  inline void set_device_ipv4_uint32(::google::protobuf::uint32 value);

  // required string interface_str = 9;
  inline bool has_interface_str() const;
  inline void clear_interface_str();
  static const int kInterfaceStrFieldNumber = 9;
  inline const ::std::string& interface_str() const;
  inline void set_interface_str(const ::std::string& value);
  inline void set_interface_str(const char* value);
  inline void set_interface_str(const char* value, size_t size);
  inline ::std::string* mutable_interface_str();
  inline ::std::string* release_interface_str();
  inline void set_allocated_interface_str(::std::string* interface_str);

  // required string log_str = 10;
  inline bool has_log_str() const;
  inline void clear_log_str();
  static const int kLogStrFieldNumber = 10;
  inline const ::std::string& log_str() const;
  inline void set_log_str(const ::std::string& value);
  inline void set_log_str(const char* value);
  inline void set_log_str(const char* value, size_t size);
  inline ::std::string* mutable_log_str();
  inline ::std::string* release_log_str();
  inline void set_allocated_log_str(::std::string* log_str);

  // required string event_id_str = 11;
  inline bool has_event_id_str() const;
  inline void clear_event_id_str();
  static const int kEventIdStrFieldNumber = 11;
  inline const ::std::string& event_id_str() const;
  inline void set_event_id_str(const ::std::string& value);
  inline void set_event_id_str(const char* value);
  inline void set_event_id_str(const char* value, size_t size);
  inline ::std::string* mutable_event_id_str();
  inline ::std::string* release_event_id_str();
  inline void set_allocated_event_id_str(::std::string* event_id_str);

  // optional .SIEM.SIEMPbMessage.SIEMProtocolType protocol_type_enum = 12;
  inline bool has_protocol_type_enum() const;
  inline void clear_protocol_type_enum();
  static const int kProtocolTypeEnumFieldNumber = 12;
  inline ::SIEM::SIEMPbMessage_SIEMProtocolType protocol_type_enum() const;
  inline void set_protocol_type_enum(::SIEM::SIEMPbMessage_SIEMProtocolType value);

  // optional uint32 src_port_uint32 = 13;
  inline bool has_src_port_uint32() const;
  inline void clear_src_port_uint32();
  static const int kSrcPortUint32FieldNumber = 13;
  inline ::google::protobuf::uint32 src_port_uint32() const;
  inline void set_src_port_uint32(::google::protobuf::uint32 value);

  // optional uint32 dst_port_uint32 = 14;
  inline bool has_dst_port_uint32() const;
  inline void clear_dst_port_uint32();
  static const int kDstPortUint32FieldNumber = 14;
  inline ::google::protobuf::uint32 dst_port_uint32() const;
  inline void set_dst_port_uint32(::google::protobuf::uint32 value);

  // optional uint32 snort_sid_uint32 = 15;
  inline bool has_snort_sid_uint32() const;
  inline void clear_snort_sid_uint32();
  static const int kSnortSidUint32FieldNumber = 15;
  inline ::google::protobuf::uint32 snort_sid_uint32() const;
  inline void set_snort_sid_uint32(::google::protobuf::uint32 value);

  // optional uint32 snort_cid_uint32 = 16;
  inline bool has_snort_cid_uint32() const;
  inline void clear_snort_cid_uint32();
  static const int kSnortCidUint32FieldNumber = 16;
  inline ::google::protobuf::uint32 snort_cid_uint32() const;
  inline void set_snort_cid_uint32(::google::protobuf::uint32 value);

  // optional uint32 priority_uint32 = 17;
  inline bool has_priority_uint32() const;
  inline void clear_priority_uint32();
  static const int kPriorityUint32FieldNumber = 17;
  inline ::google::protobuf::uint32 priority_uint32() const;
  inline void set_priority_uint32(::google::protobuf::uint32 value);

  // optional uint32 occurrences_uint32 = 18;
  inline bool has_occurrences_uint32() const;
  inline void clear_occurrences_uint32();
  static const int kOccurrencesUint32FieldNumber = 18;
  inline ::google::protobuf::uint32 occurrences_uint32() const;
  inline void set_occurrences_uint32(::google::protobuf::uint32 value);

  // optional string ctx_str = 19;
  inline bool has_ctx_str() const;
  inline void clear_ctx_str();
  static const int kCtxStrFieldNumber = 19;
  inline const ::std::string& ctx_str() const;
  inline void set_ctx_str(const ::std::string& value);
  inline void set_ctx_str(const char* value);
  inline void set_ctx_str(const char* value, size_t size);
  inline ::std::string* mutable_ctx_str();
  inline ::std::string* release_ctx_str();
  inline void set_allocated_ctx_str(::std::string* ctx_str);

  // optional string username_str = 20;
  inline bool has_username_str() const;
  inline void clear_username_str();
  static const int kUsernameStrFieldNumber = 20;
  inline const ::std::string& username_str() const;
  inline void set_username_str(const ::std::string& value);
  inline void set_username_str(const char* value);
  inline void set_username_str(const char* value, size_t size);
  inline ::std::string* mutable_username_str();
  inline ::std::string* release_username_str();
  inline void set_allocated_username_str(::std::string* username_str);

  // optional string password_str = 21;
  inline bool has_password_str() const;
  inline void clear_password_str();
  static const int kPasswordStrFieldNumber = 21;
  inline const ::std::string& password_str() const;
  inline void set_password_str(const ::std::string& value);
  inline void set_password_str(const char* value);
  inline void set_password_str(const char* value, size_t size);
  inline ::std::string* mutable_password_str();
  inline ::std::string* release_password_str();
  inline void set_allocated_password_str(::std::string* password_str);

  // optional string filename_str = 22;
  inline bool has_filename_str() const;
  inline void clear_filename_str();
  static const int kFilenameStrFieldNumber = 22;
  inline const ::std::string& filename_str() const;
  inline void set_filename_str(const ::std::string& value);
  inline void set_filename_str(const char* value);
  inline void set_filename_str(const char* value, size_t size);
  inline ::std::string* mutable_filename_str();
  inline ::std::string* release_filename_str();
  inline void set_allocated_filename_str(::std::string* filename_str);

  // optional string userdata1_str = 23;
  inline bool has_userdata1_str() const;
  inline void clear_userdata1_str();
  static const int kUserdata1StrFieldNumber = 23;
  inline const ::std::string& userdata1_str() const;
  inline void set_userdata1_str(const ::std::string& value);
  inline void set_userdata1_str(const char* value);
  inline void set_userdata1_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata1_str();
  inline ::std::string* release_userdata1_str();
  inline void set_allocated_userdata1_str(::std::string* userdata1_str);

  // optional string userdata2_str = 24;
  inline bool has_userdata2_str() const;
  inline void clear_userdata2_str();
  static const int kUserdata2StrFieldNumber = 24;
  inline const ::std::string& userdata2_str() const;
  inline void set_userdata2_str(const ::std::string& value);
  inline void set_userdata2_str(const char* value);
  inline void set_userdata2_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata2_str();
  inline ::std::string* release_userdata2_str();
  inline void set_allocated_userdata2_str(::std::string* userdata2_str);

  // optional string userdata3_str = 25;
  inline bool has_userdata3_str() const;
  inline void clear_userdata3_str();
  static const int kUserdata3StrFieldNumber = 25;
  inline const ::std::string& userdata3_str() const;
  inline void set_userdata3_str(const ::std::string& value);
  inline void set_userdata3_str(const char* value);
  inline void set_userdata3_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata3_str();
  inline ::std::string* release_userdata3_str();
  inline void set_allocated_userdata3_str(::std::string* userdata3_str);

  // optional string userdata4_str = 26;
  inline bool has_userdata4_str() const;
  inline void clear_userdata4_str();
  static const int kUserdata4StrFieldNumber = 26;
  inline const ::std::string& userdata4_str() const;
  inline void set_userdata4_str(const ::std::string& value);
  inline void set_userdata4_str(const char* value);
  inline void set_userdata4_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata4_str();
  inline ::std::string* release_userdata4_str();
  inline void set_allocated_userdata4_str(::std::string* userdata4_str);

  // optional string userdata5_str = 27;
  inline bool has_userdata5_str() const;
  inline void clear_userdata5_str();
  static const int kUserdata5StrFieldNumber = 27;
  inline const ::std::string& userdata5_str() const;
  inline void set_userdata5_str(const ::std::string& value);
  inline void set_userdata5_str(const char* value);
  inline void set_userdata5_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata5_str();
  inline ::std::string* release_userdata5_str();
  inline void set_allocated_userdata5_str(::std::string* userdata5_str);

  // optional string userdata6_str = 28;
  inline bool has_userdata6_str() const;
  inline void clear_userdata6_str();
  static const int kUserdata6StrFieldNumber = 28;
  inline const ::std::string& userdata6_str() const;
  inline void set_userdata6_str(const ::std::string& value);
  inline void set_userdata6_str(const char* value);
  inline void set_userdata6_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata6_str();
  inline ::std::string* release_userdata6_str();
  inline void set_allocated_userdata6_str(::std::string* userdata6_str);

  // optional string userdata7_str = 29;
  inline bool has_userdata7_str() const;
  inline void clear_userdata7_str();
  static const int kUserdata7StrFieldNumber = 29;
  inline const ::std::string& userdata7_str() const;
  inline void set_userdata7_str(const ::std::string& value);
  inline void set_userdata7_str(const char* value);
  inline void set_userdata7_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata7_str();
  inline ::std::string* release_userdata7_str();
  inline void set_allocated_userdata7_str(::std::string* userdata7_str);

  // optional string userdata8_str = 30;
  inline bool has_userdata8_str() const;
  inline void clear_userdata8_str();
  static const int kUserdata8StrFieldNumber = 30;
  inline const ::std::string& userdata8_str() const;
  inline void set_userdata8_str(const ::std::string& value);
  inline void set_userdata8_str(const char* value);
  inline void set_userdata8_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata8_str();
  inline ::std::string* release_userdata8_str();
  inline void set_allocated_userdata8_str(::std::string* userdata8_str);

  // optional string userdata9_str = 31;
  inline bool has_userdata9_str() const;
  inline void clear_userdata9_str();
  static const int kUserdata9StrFieldNumber = 31;
  inline const ::std::string& userdata9_str() const;
  inline void set_userdata9_str(const ::std::string& value);
  inline void set_userdata9_str(const char* value);
  inline void set_userdata9_str(const char* value, size_t size);
  inline ::std::string* mutable_userdata9_str();
  inline ::std::string* release_userdata9_str();
  inline void set_allocated_userdata9_str(::std::string* userdata9_str);

  // optional string sensor_id_str = 32;
  inline bool has_sensor_id_str() const;
  inline void clear_sensor_id_str();
  static const int kSensorIdStrFieldNumber = 32;
  inline const ::std::string& sensor_id_str() const;
  inline void set_sensor_id_str(const ::std::string& value);
  inline void set_sensor_id_str(const char* value);
  inline void set_sensor_id_str(const char* value, size_t size);
  inline ::std::string* mutable_sensor_id_str();
  inline ::std::string* release_sensor_id_str();
  inline void set_allocated_sensor_id_str(::std::string* sensor_id_str);

  // optional string binary_data_str = 33;
  inline bool has_binary_data_str() const;
  inline void clear_binary_data_str();
  static const int kBinaryDataStrFieldNumber = 33;
  inline const ::std::string& binary_data_str() const;
  inline void set_binary_data_str(const ::std::string& value);
  inline void set_binary_data_str(const char* value);
  inline void set_binary_data_str(const char* value, size_t size);
  inline ::std::string* mutable_binary_data_str();
  inline ::std::string* release_binary_data_str();
  inline void set_allocated_binary_data_str(::std::string* binary_data_str);

  // @@protoc_insertion_point(class_scope:SIEM.SIEMPbMessage.SIEMPbEvent)
 private:
  inline void set_has_plugin_id_uint32();
  inline void clear_has_plugin_id_uint32();
  inline void set_has_plugin_sid_uint32();
  inline void clear_has_plugin_sid_uint32();
  inline void set_has_data_uint32();
  inline void clear_has_data_uint32();
  inline void set_has_fdata_uint32();
  inline void clear_has_fdata_uint32();
  inline void set_has_event_type_enum();
  inline void clear_has_event_type_enum();
  inline void set_has_src_ipv4_uint32();
  inline void clear_has_src_ipv4_uint32();
  inline void set_has_dst_ipv4_uint32();
  inline void clear_has_dst_ipv4_uint32();
  inline void set_has_device_ipv4_uint32();
  inline void clear_has_device_ipv4_uint32();
  inline void set_has_interface_str();
  inline void clear_has_interface_str();
  inline void set_has_log_str();
  inline void clear_has_log_str();
  inline void set_has_event_id_str();
  inline void clear_has_event_id_str();
  inline void set_has_protocol_type_enum();
  inline void clear_has_protocol_type_enum();
  inline void set_has_src_port_uint32();
  inline void clear_has_src_port_uint32();
  inline void set_has_dst_port_uint32();
  inline void clear_has_dst_port_uint32();
  inline void set_has_snort_sid_uint32();
  inline void clear_has_snort_sid_uint32();
  inline void set_has_snort_cid_uint32();
  inline void clear_has_snort_cid_uint32();
  inline void set_has_priority_uint32();
  inline void clear_has_priority_uint32();
  inline void set_has_occurrences_uint32();
  inline void clear_has_occurrences_uint32();
  inline void set_has_ctx_str();
  inline void clear_has_ctx_str();
  inline void set_has_username_str();
  inline void clear_has_username_str();
  inline void set_has_password_str();
  inline void clear_has_password_str();
  inline void set_has_filename_str();
  inline void clear_has_filename_str();
  inline void set_has_userdata1_str();
  inline void clear_has_userdata1_str();
  inline void set_has_userdata2_str();
  inline void clear_has_userdata2_str();
  inline void set_has_userdata3_str();
  inline void clear_has_userdata3_str();
  inline void set_has_userdata4_str();
  inline void clear_has_userdata4_str();
  inline void set_has_userdata5_str();
  inline void clear_has_userdata5_str();
  inline void set_has_userdata6_str();
  inline void clear_has_userdata6_str();
  inline void set_has_userdata7_str();
  inline void clear_has_userdata7_str();
  inline void set_has_userdata8_str();
  inline void clear_has_userdata8_str();
  inline void set_has_userdata9_str();
  inline void clear_has_userdata9_str();
  inline void set_has_sensor_id_str();
  inline void clear_has_sensor_id_str();
  inline void set_has_binary_data_str();
  inline void clear_has_binary_data_str();

  ::google::protobuf::uint32 plugin_id_uint32_;
  ::google::protobuf::uint32 plugin_sid_uint32_;
  ::google::protobuf::uint32 data_uint32_;
  ::google::protobuf::uint32 fdata_uint32_;
  int event_type_enum_;
  ::google::protobuf::uint32 src_ipv4_uint32_;
  ::google::protobuf::uint32 dst_ipv4_uint32_;
  ::google::protobuf::uint32 device_ipv4_uint32_;
  ::std::string* interface_str_;
  ::std::string* log_str_;
  ::std::string* event_id_str_;
  int protocol_type_enum_;
  ::google::protobuf::uint32 src_port_uint32_;
  ::google::protobuf::uint32 dst_port_uint32_;
  ::google::protobuf::uint32 snort_sid_uint32_;
  ::google::protobuf::uint32 snort_cid_uint32_;
  ::google::protobuf::uint32 priority_uint32_;
  ::std::string* ctx_str_;
  ::std::string* username_str_;
  ::std::string* password_str_;
  ::std::string* filename_str_;
  ::std::string* userdata1_str_;
  ::std::string* userdata2_str_;
  ::std::string* userdata3_str_;
  ::std::string* userdata4_str_;
  ::std::string* userdata5_str_;
  ::std::string* userdata6_str_;
  ::std::string* userdata7_str_;
  ::std::string* userdata8_str_;
  ::std::string* userdata9_str_;
  ::std::string* sensor_id_str_;
  ::std::string* binary_data_str_;
  ::google::protobuf::uint32 occurrences_uint32_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SIEMMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SIEMMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_SIEMMessage_2eproto();
  friend void protobuf_ShutdownFile_SIEMMessage_2eproto();

  void InitAsDefaultInstance();
  static SIEMPbMessage_SIEMPbEvent* default_instance_;
};
// -------------------------------------------------------------------

class SIEMPbMessage : public ::google::protobuf::MessageLite {
 public:
  SIEMPbMessage();
  virtual ~SIEMPbMessage();

  SIEMPbMessage(const SIEMPbMessage& from);

  inline SIEMPbMessage& operator=(const SIEMPbMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SIEMPbMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SIEMPbMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SIEMPbMessage* other);

  // implements Message ----------------------------------------------

  SIEMPbMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SIEMPbMessage& from);
  void MergeFrom(const SIEMPbMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SIEMPbMessage_SIEMPbEvent SIEMPbEvent;

  typedef SIEMPbMessage_SIEMProtocolType SIEMProtocolType;
  static const SIEMProtocolType SIEM_PROTOCOL_NONE = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_NONE;
  static const SIEMProtocolType SIEM_PROTOCOL_ICMP = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_ICMP;
  static const SIEMProtocolType SIEM_PROTOCOL_TCP = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_TCP;
  static const SIEMProtocolType SIEM_PROTOCOL_UDP = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_UDP;
  static const SIEMProtocolType SIEM_PROTOCOL_ARP_EVENT = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_ARP_EVENT;
  static const SIEMProtocolType SIEM_PROTOCOL_OS_EVENT = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_OS_EVENT;
  static const SIEMProtocolType SIEM_PROTOCOL_SERVER_EVENT = SIEMPbMessage_SIEMProtocolType_SIEM_PROTOCOL_SERVER_EVENT;
  static inline bool SIEMProtocolType_IsValid(int value) {
    return SIEMPbMessage_SIEMProtocolType_IsValid(value);
  }
  static const SIEMProtocolType SIEMProtocolType_MIN =
    SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_MIN;
  static const SIEMProtocolType SIEMProtocolType_MAX =
    SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_MAX;
  static const int SIEMProtocolType_ARRAYSIZE =
    SIEMPbMessage_SIEMProtocolType_SIEMProtocolType_ARRAYSIZE;

  typedef SIEMPbMessage_SIEMEventType SIEMEventType;
  static const SIEMEventType SIEM_EVENT_NONE = SIEMPbMessage_SIEMEventType_SIEM_EVENT_NONE;
  static const SIEMEventType SIEM_EVENT_DETECTOR = SIEMPbMessage_SIEMEventType_SIEM_EVENT_DETECTOR;
  static const SIEMEventType SIEM_EVENT_MONITOR = SIEMPbMessage_SIEMEventType_SIEM_EVENT_MONITOR;
  static const SIEMEventType SIEM_EVENT_BACKLOG = SIEMPbMessage_SIEMEventType_SIEM_EVENT_BACKLOG;
  static inline bool SIEMEventType_IsValid(int value) {
    return SIEMPbMessage_SIEMEventType_IsValid(value);
  }
  static const SIEMEventType SIEMEventType_MIN =
    SIEMPbMessage_SIEMEventType_SIEMEventType_MIN;
  static const SIEMEventType SIEMEventType_MAX =
    SIEMPbMessage_SIEMEventType_SIEMEventType_MAX;
  static const int SIEMEventType_ARRAYSIZE =
    SIEMPbMessage_SIEMEventType_SIEMEventType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .SIEM.SIEMPbMessage.SIEMPbEvent siem_event = 1;
  inline bool has_siem_event() const;
  inline void clear_siem_event();
  static const int kSiemEventFieldNumber = 1;
  inline const ::SIEM::SIEMPbMessage_SIEMPbEvent& siem_event() const;
  inline ::SIEM::SIEMPbMessage_SIEMPbEvent* mutable_siem_event();
  inline ::SIEM::SIEMPbMessage_SIEMPbEvent* release_siem_event();
  inline void set_allocated_siem_event(::SIEM::SIEMPbMessage_SIEMPbEvent* siem_event);

  // @@protoc_insertion_point(class_scope:SIEM.SIEMPbMessage)
 private:
  inline void set_has_siem_event();
  inline void clear_has_siem_event();

  ::SIEM::SIEMPbMessage_SIEMPbEvent* siem_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SIEMMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SIEMMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_SIEMMessage_2eproto();
  friend void protobuf_ShutdownFile_SIEMMessage_2eproto();

  void InitAsDefaultInstance();
  static SIEMPbMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// SIEMPbMessage_SIEMPbEvent

// required uint32 plugin_id_uint32 = 1;
inline bool SIEMPbMessage_SIEMPbEvent::has_plugin_id_uint32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_plugin_id_uint32() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_plugin_id_uint32() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_plugin_id_uint32() {
  plugin_id_uint32_ = 0u;
  clear_has_plugin_id_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::plugin_id_uint32() const {
  return plugin_id_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_plugin_id_uint32(::google::protobuf::uint32 value) {
  set_has_plugin_id_uint32();
  plugin_id_uint32_ = value;
}

// required uint32 plugin_sid_uint32 = 2;
inline bool SIEMPbMessage_SIEMPbEvent::has_plugin_sid_uint32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_plugin_sid_uint32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_plugin_sid_uint32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_plugin_sid_uint32() {
  plugin_sid_uint32_ = 0u;
  clear_has_plugin_sid_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::plugin_sid_uint32() const {
  return plugin_sid_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_plugin_sid_uint32(::google::protobuf::uint32 value) {
  set_has_plugin_sid_uint32();
  plugin_sid_uint32_ = value;
}

// required uint32 data_uint32 = 3;
inline bool SIEMPbMessage_SIEMPbEvent::has_data_uint32() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_data_uint32() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_data_uint32() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_data_uint32() {
  data_uint32_ = 0u;
  clear_has_data_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::data_uint32() const {
  return data_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_data_uint32(::google::protobuf::uint32 value) {
  set_has_data_uint32();
  data_uint32_ = value;
}

// required uint32 fdata_uint32 = 4;
inline bool SIEMPbMessage_SIEMPbEvent::has_fdata_uint32() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_fdata_uint32() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_fdata_uint32() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_fdata_uint32() {
  fdata_uint32_ = 0u;
  clear_has_fdata_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::fdata_uint32() const {
  return fdata_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_fdata_uint32(::google::protobuf::uint32 value) {
  set_has_fdata_uint32();
  fdata_uint32_ = value;
}

// required .SIEM.SIEMPbMessage.SIEMEventType event_type_enum = 5;
inline bool SIEMPbMessage_SIEMPbEvent::has_event_type_enum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_event_type_enum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_event_type_enum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_event_type_enum() {
  event_type_enum_ = -1;
  clear_has_event_type_enum();
}
inline ::SIEM::SIEMPbMessage_SIEMEventType SIEMPbMessage_SIEMPbEvent::event_type_enum() const {
  return static_cast< ::SIEM::SIEMPbMessage_SIEMEventType >(event_type_enum_);
}
inline void SIEMPbMessage_SIEMPbEvent::set_event_type_enum(::SIEM::SIEMPbMessage_SIEMEventType value) {
  assert(::SIEM::SIEMPbMessage_SIEMEventType_IsValid(value));
  set_has_event_type_enum();
  event_type_enum_ = value;
}

// required uint32 src_ipv4_uint32 = 6;
inline bool SIEMPbMessage_SIEMPbEvent::has_src_ipv4_uint32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_src_ipv4_uint32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_src_ipv4_uint32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_src_ipv4_uint32() {
  src_ipv4_uint32_ = 0u;
  clear_has_src_ipv4_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::src_ipv4_uint32() const {
  return src_ipv4_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_src_ipv4_uint32(::google::protobuf::uint32 value) {
  set_has_src_ipv4_uint32();
  src_ipv4_uint32_ = value;
}

// required uint32 dst_ipv4_uint32 = 7;
inline bool SIEMPbMessage_SIEMPbEvent::has_dst_ipv4_uint32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_dst_ipv4_uint32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_dst_ipv4_uint32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_dst_ipv4_uint32() {
  dst_ipv4_uint32_ = 0u;
  clear_has_dst_ipv4_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::dst_ipv4_uint32() const {
  return dst_ipv4_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_dst_ipv4_uint32(::google::protobuf::uint32 value) {
  set_has_dst_ipv4_uint32();
  dst_ipv4_uint32_ = value;
}

// required uint32 device_ipv4_uint32 = 8;
inline bool SIEMPbMessage_SIEMPbEvent::has_device_ipv4_uint32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_device_ipv4_uint32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_device_ipv4_uint32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_device_ipv4_uint32() {
  device_ipv4_uint32_ = 0u;
  clear_has_device_ipv4_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::device_ipv4_uint32() const {
  return device_ipv4_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_device_ipv4_uint32(::google::protobuf::uint32 value) {
  set_has_device_ipv4_uint32();
  device_ipv4_uint32_ = value;
}

// required string interface_str = 9;
inline bool SIEMPbMessage_SIEMPbEvent::has_interface_str() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_interface_str() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_interface_str() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_interface_str() {
  if (interface_str_ != &::google::protobuf::internal::kEmptyString) {
    interface_str_->clear();
  }
  clear_has_interface_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::interface_str() const {
  return *interface_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_interface_str(const ::std::string& value) {
  set_has_interface_str();
  if (interface_str_ == &::google::protobuf::internal::kEmptyString) {
    interface_str_ = new ::std::string;
  }
  interface_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_interface_str(const char* value) {
  set_has_interface_str();
  if (interface_str_ == &::google::protobuf::internal::kEmptyString) {
    interface_str_ = new ::std::string;
  }
  interface_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_interface_str(const char* value, size_t size) {
  set_has_interface_str();
  if (interface_str_ == &::google::protobuf::internal::kEmptyString) {
    interface_str_ = new ::std::string;
  }
  interface_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_interface_str() {
  set_has_interface_str();
  if (interface_str_ == &::google::protobuf::internal::kEmptyString) {
    interface_str_ = new ::std::string;
  }
  return interface_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_interface_str() {
  clear_has_interface_str();
  if (interface_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interface_str_;
    interface_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_interface_str(::std::string* interface_str) {
  if (interface_str_ != &::google::protobuf::internal::kEmptyString) {
    delete interface_str_;
  }
  if (interface_str) {
    set_has_interface_str();
    interface_str_ = interface_str;
  } else {
    clear_has_interface_str();
    interface_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string log_str = 10;
inline bool SIEMPbMessage_SIEMPbEvent::has_log_str() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_log_str() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_log_str() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_log_str() {
  if (log_str_ != &::google::protobuf::internal::kEmptyString) {
    log_str_->clear();
  }
  clear_has_log_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::log_str() const {
  return *log_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_log_str(const ::std::string& value) {
  set_has_log_str();
  if (log_str_ == &::google::protobuf::internal::kEmptyString) {
    log_str_ = new ::std::string;
  }
  log_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_log_str(const char* value) {
  set_has_log_str();
  if (log_str_ == &::google::protobuf::internal::kEmptyString) {
    log_str_ = new ::std::string;
  }
  log_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_log_str(const char* value, size_t size) {
  set_has_log_str();
  if (log_str_ == &::google::protobuf::internal::kEmptyString) {
    log_str_ = new ::std::string;
  }
  log_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_log_str() {
  set_has_log_str();
  if (log_str_ == &::google::protobuf::internal::kEmptyString) {
    log_str_ = new ::std::string;
  }
  return log_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_log_str() {
  clear_has_log_str();
  if (log_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_str_;
    log_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_log_str(::std::string* log_str) {
  if (log_str_ != &::google::protobuf::internal::kEmptyString) {
    delete log_str_;
  }
  if (log_str) {
    set_has_log_str();
    log_str_ = log_str;
  } else {
    clear_has_log_str();
    log_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event_id_str = 11;
inline bool SIEMPbMessage_SIEMPbEvent::has_event_id_str() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_event_id_str() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_event_id_str() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_event_id_str() {
  if (event_id_str_ != &::google::protobuf::internal::kEmptyString) {
    event_id_str_->clear();
  }
  clear_has_event_id_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::event_id_str() const {
  return *event_id_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_event_id_str(const ::std::string& value) {
  set_has_event_id_str();
  if (event_id_str_ == &::google::protobuf::internal::kEmptyString) {
    event_id_str_ = new ::std::string;
  }
  event_id_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_event_id_str(const char* value) {
  set_has_event_id_str();
  if (event_id_str_ == &::google::protobuf::internal::kEmptyString) {
    event_id_str_ = new ::std::string;
  }
  event_id_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_event_id_str(const char* value, size_t size) {
  set_has_event_id_str();
  if (event_id_str_ == &::google::protobuf::internal::kEmptyString) {
    event_id_str_ = new ::std::string;
  }
  event_id_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_event_id_str() {
  set_has_event_id_str();
  if (event_id_str_ == &::google::protobuf::internal::kEmptyString) {
    event_id_str_ = new ::std::string;
  }
  return event_id_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_event_id_str() {
  clear_has_event_id_str();
  if (event_id_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_id_str_;
    event_id_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_event_id_str(::std::string* event_id_str) {
  if (event_id_str_ != &::google::protobuf::internal::kEmptyString) {
    delete event_id_str_;
  }
  if (event_id_str) {
    set_has_event_id_str();
    event_id_str_ = event_id_str;
  } else {
    clear_has_event_id_str();
    event_id_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SIEM.SIEMPbMessage.SIEMProtocolType protocol_type_enum = 12;
inline bool SIEMPbMessage_SIEMPbEvent::has_protocol_type_enum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_protocol_type_enum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_protocol_type_enum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_protocol_type_enum() {
  protocol_type_enum_ = -1;
  clear_has_protocol_type_enum();
}
inline ::SIEM::SIEMPbMessage_SIEMProtocolType SIEMPbMessage_SIEMPbEvent::protocol_type_enum() const {
  return static_cast< ::SIEM::SIEMPbMessage_SIEMProtocolType >(protocol_type_enum_);
}
inline void SIEMPbMessage_SIEMPbEvent::set_protocol_type_enum(::SIEM::SIEMPbMessage_SIEMProtocolType value) {
  assert(::SIEM::SIEMPbMessage_SIEMProtocolType_IsValid(value));
  set_has_protocol_type_enum();
  protocol_type_enum_ = value;
}

// optional uint32 src_port_uint32 = 13;
inline bool SIEMPbMessage_SIEMPbEvent::has_src_port_uint32() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_src_port_uint32() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_src_port_uint32() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_src_port_uint32() {
  src_port_uint32_ = 0u;
  clear_has_src_port_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::src_port_uint32() const {
  return src_port_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_src_port_uint32(::google::protobuf::uint32 value) {
  set_has_src_port_uint32();
  src_port_uint32_ = value;
}

// optional uint32 dst_port_uint32 = 14;
inline bool SIEMPbMessage_SIEMPbEvent::has_dst_port_uint32() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_dst_port_uint32() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_dst_port_uint32() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_dst_port_uint32() {
  dst_port_uint32_ = 0u;
  clear_has_dst_port_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::dst_port_uint32() const {
  return dst_port_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_dst_port_uint32(::google::protobuf::uint32 value) {
  set_has_dst_port_uint32();
  dst_port_uint32_ = value;
}

// optional uint32 snort_sid_uint32 = 15;
inline bool SIEMPbMessage_SIEMPbEvent::has_snort_sid_uint32() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_snort_sid_uint32() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_snort_sid_uint32() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_snort_sid_uint32() {
  snort_sid_uint32_ = 0u;
  clear_has_snort_sid_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::snort_sid_uint32() const {
  return snort_sid_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_snort_sid_uint32(::google::protobuf::uint32 value) {
  set_has_snort_sid_uint32();
  snort_sid_uint32_ = value;
}

// optional uint32 snort_cid_uint32 = 16;
inline bool SIEMPbMessage_SIEMPbEvent::has_snort_cid_uint32() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_snort_cid_uint32() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_snort_cid_uint32() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_snort_cid_uint32() {
  snort_cid_uint32_ = 0u;
  clear_has_snort_cid_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::snort_cid_uint32() const {
  return snort_cid_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_snort_cid_uint32(::google::protobuf::uint32 value) {
  set_has_snort_cid_uint32();
  snort_cid_uint32_ = value;
}

// optional uint32 priority_uint32 = 17;
inline bool SIEMPbMessage_SIEMPbEvent::has_priority_uint32() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_priority_uint32() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_priority_uint32() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_priority_uint32() {
  priority_uint32_ = 0u;
  clear_has_priority_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::priority_uint32() const {
  return priority_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_priority_uint32(::google::protobuf::uint32 value) {
  set_has_priority_uint32();
  priority_uint32_ = value;
}

// optional uint32 occurrences_uint32 = 18;
inline bool SIEMPbMessage_SIEMPbEvent::has_occurrences_uint32() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_occurrences_uint32() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_occurrences_uint32() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_occurrences_uint32() {
  occurrences_uint32_ = 0u;
  clear_has_occurrences_uint32();
}
inline ::google::protobuf::uint32 SIEMPbMessage_SIEMPbEvent::occurrences_uint32() const {
  return occurrences_uint32_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_occurrences_uint32(::google::protobuf::uint32 value) {
  set_has_occurrences_uint32();
  occurrences_uint32_ = value;
}

// optional string ctx_str = 19;
inline bool SIEMPbMessage_SIEMPbEvent::has_ctx_str() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_ctx_str() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_ctx_str() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_ctx_str() {
  if (ctx_str_ != &::google::protobuf::internal::kEmptyString) {
    ctx_str_->clear();
  }
  clear_has_ctx_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::ctx_str() const {
  return *ctx_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_ctx_str(const ::std::string& value) {
  set_has_ctx_str();
  if (ctx_str_ == &::google::protobuf::internal::kEmptyString) {
    ctx_str_ = new ::std::string;
  }
  ctx_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_ctx_str(const char* value) {
  set_has_ctx_str();
  if (ctx_str_ == &::google::protobuf::internal::kEmptyString) {
    ctx_str_ = new ::std::string;
  }
  ctx_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_ctx_str(const char* value, size_t size) {
  set_has_ctx_str();
  if (ctx_str_ == &::google::protobuf::internal::kEmptyString) {
    ctx_str_ = new ::std::string;
  }
  ctx_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_ctx_str() {
  set_has_ctx_str();
  if (ctx_str_ == &::google::protobuf::internal::kEmptyString) {
    ctx_str_ = new ::std::string;
  }
  return ctx_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_ctx_str() {
  clear_has_ctx_str();
  if (ctx_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ctx_str_;
    ctx_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_ctx_str(::std::string* ctx_str) {
  if (ctx_str_ != &::google::protobuf::internal::kEmptyString) {
    delete ctx_str_;
  }
  if (ctx_str) {
    set_has_ctx_str();
    ctx_str_ = ctx_str;
  } else {
    clear_has_ctx_str();
    ctx_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username_str = 20;
inline bool SIEMPbMessage_SIEMPbEvent::has_username_str() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_username_str() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_username_str() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_username_str() {
  if (username_str_ != &::google::protobuf::internal::kEmptyString) {
    username_str_->clear();
  }
  clear_has_username_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::username_str() const {
  return *username_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_username_str(const ::std::string& value) {
  set_has_username_str();
  if (username_str_ == &::google::protobuf::internal::kEmptyString) {
    username_str_ = new ::std::string;
  }
  username_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_username_str(const char* value) {
  set_has_username_str();
  if (username_str_ == &::google::protobuf::internal::kEmptyString) {
    username_str_ = new ::std::string;
  }
  username_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_username_str(const char* value, size_t size) {
  set_has_username_str();
  if (username_str_ == &::google::protobuf::internal::kEmptyString) {
    username_str_ = new ::std::string;
  }
  username_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_username_str() {
  set_has_username_str();
  if (username_str_ == &::google::protobuf::internal::kEmptyString) {
    username_str_ = new ::std::string;
  }
  return username_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_username_str() {
  clear_has_username_str();
  if (username_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_str_;
    username_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_username_str(::std::string* username_str) {
  if (username_str_ != &::google::protobuf::internal::kEmptyString) {
    delete username_str_;
  }
  if (username_str) {
    set_has_username_str();
    username_str_ = username_str;
  } else {
    clear_has_username_str();
    username_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password_str = 21;
inline bool SIEMPbMessage_SIEMPbEvent::has_password_str() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_password_str() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_password_str() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_password_str() {
  if (password_str_ != &::google::protobuf::internal::kEmptyString) {
    password_str_->clear();
  }
  clear_has_password_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::password_str() const {
  return *password_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_password_str(const ::std::string& value) {
  set_has_password_str();
  if (password_str_ == &::google::protobuf::internal::kEmptyString) {
    password_str_ = new ::std::string;
  }
  password_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_password_str(const char* value) {
  set_has_password_str();
  if (password_str_ == &::google::protobuf::internal::kEmptyString) {
    password_str_ = new ::std::string;
  }
  password_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_password_str(const char* value, size_t size) {
  set_has_password_str();
  if (password_str_ == &::google::protobuf::internal::kEmptyString) {
    password_str_ = new ::std::string;
  }
  password_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_password_str() {
  set_has_password_str();
  if (password_str_ == &::google::protobuf::internal::kEmptyString) {
    password_str_ = new ::std::string;
  }
  return password_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_password_str() {
  clear_has_password_str();
  if (password_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_str_;
    password_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_password_str(::std::string* password_str) {
  if (password_str_ != &::google::protobuf::internal::kEmptyString) {
    delete password_str_;
  }
  if (password_str) {
    set_has_password_str();
    password_str_ = password_str;
  } else {
    clear_has_password_str();
    password_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename_str = 22;
inline bool SIEMPbMessage_SIEMPbEvent::has_filename_str() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_filename_str() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_filename_str() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_filename_str() {
  if (filename_str_ != &::google::protobuf::internal::kEmptyString) {
    filename_str_->clear();
  }
  clear_has_filename_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::filename_str() const {
  return *filename_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_filename_str(const ::std::string& value) {
  set_has_filename_str();
  if (filename_str_ == &::google::protobuf::internal::kEmptyString) {
    filename_str_ = new ::std::string;
  }
  filename_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_filename_str(const char* value) {
  set_has_filename_str();
  if (filename_str_ == &::google::protobuf::internal::kEmptyString) {
    filename_str_ = new ::std::string;
  }
  filename_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_filename_str(const char* value, size_t size) {
  set_has_filename_str();
  if (filename_str_ == &::google::protobuf::internal::kEmptyString) {
    filename_str_ = new ::std::string;
  }
  filename_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_filename_str() {
  set_has_filename_str();
  if (filename_str_ == &::google::protobuf::internal::kEmptyString) {
    filename_str_ = new ::std::string;
  }
  return filename_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_filename_str() {
  clear_has_filename_str();
  if (filename_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_str_;
    filename_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_filename_str(::std::string* filename_str) {
  if (filename_str_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_str_;
  }
  if (filename_str) {
    set_has_filename_str();
    filename_str_ = filename_str;
  } else {
    clear_has_filename_str();
    filename_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata1_str = 23;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata1_str() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata1_str() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata1_str() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata1_str() {
  if (userdata1_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata1_str_->clear();
  }
  clear_has_userdata1_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata1_str() const {
  return *userdata1_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata1_str(const ::std::string& value) {
  set_has_userdata1_str();
  if (userdata1_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata1_str_ = new ::std::string;
  }
  userdata1_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata1_str(const char* value) {
  set_has_userdata1_str();
  if (userdata1_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata1_str_ = new ::std::string;
  }
  userdata1_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata1_str(const char* value, size_t size) {
  set_has_userdata1_str();
  if (userdata1_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata1_str_ = new ::std::string;
  }
  userdata1_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata1_str() {
  set_has_userdata1_str();
  if (userdata1_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata1_str_ = new ::std::string;
  }
  return userdata1_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata1_str() {
  clear_has_userdata1_str();
  if (userdata1_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata1_str_;
    userdata1_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata1_str(::std::string* userdata1_str) {
  if (userdata1_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata1_str_;
  }
  if (userdata1_str) {
    set_has_userdata1_str();
    userdata1_str_ = userdata1_str;
  } else {
    clear_has_userdata1_str();
    userdata1_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata2_str = 24;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata2_str() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata2_str() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata2_str() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata2_str() {
  if (userdata2_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata2_str_->clear();
  }
  clear_has_userdata2_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata2_str() const {
  return *userdata2_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata2_str(const ::std::string& value) {
  set_has_userdata2_str();
  if (userdata2_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata2_str_ = new ::std::string;
  }
  userdata2_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata2_str(const char* value) {
  set_has_userdata2_str();
  if (userdata2_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata2_str_ = new ::std::string;
  }
  userdata2_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata2_str(const char* value, size_t size) {
  set_has_userdata2_str();
  if (userdata2_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata2_str_ = new ::std::string;
  }
  userdata2_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata2_str() {
  set_has_userdata2_str();
  if (userdata2_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata2_str_ = new ::std::string;
  }
  return userdata2_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata2_str() {
  clear_has_userdata2_str();
  if (userdata2_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata2_str_;
    userdata2_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata2_str(::std::string* userdata2_str) {
  if (userdata2_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata2_str_;
  }
  if (userdata2_str) {
    set_has_userdata2_str();
    userdata2_str_ = userdata2_str;
  } else {
    clear_has_userdata2_str();
    userdata2_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata3_str = 25;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata3_str() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata3_str() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata3_str() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata3_str() {
  if (userdata3_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata3_str_->clear();
  }
  clear_has_userdata3_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata3_str() const {
  return *userdata3_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata3_str(const ::std::string& value) {
  set_has_userdata3_str();
  if (userdata3_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata3_str_ = new ::std::string;
  }
  userdata3_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata3_str(const char* value) {
  set_has_userdata3_str();
  if (userdata3_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata3_str_ = new ::std::string;
  }
  userdata3_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata3_str(const char* value, size_t size) {
  set_has_userdata3_str();
  if (userdata3_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata3_str_ = new ::std::string;
  }
  userdata3_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata3_str() {
  set_has_userdata3_str();
  if (userdata3_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata3_str_ = new ::std::string;
  }
  return userdata3_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata3_str() {
  clear_has_userdata3_str();
  if (userdata3_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata3_str_;
    userdata3_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata3_str(::std::string* userdata3_str) {
  if (userdata3_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata3_str_;
  }
  if (userdata3_str) {
    set_has_userdata3_str();
    userdata3_str_ = userdata3_str;
  } else {
    clear_has_userdata3_str();
    userdata3_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata4_str = 26;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata4_str() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata4_str() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata4_str() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata4_str() {
  if (userdata4_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata4_str_->clear();
  }
  clear_has_userdata4_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata4_str() const {
  return *userdata4_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata4_str(const ::std::string& value) {
  set_has_userdata4_str();
  if (userdata4_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata4_str_ = new ::std::string;
  }
  userdata4_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata4_str(const char* value) {
  set_has_userdata4_str();
  if (userdata4_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata4_str_ = new ::std::string;
  }
  userdata4_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata4_str(const char* value, size_t size) {
  set_has_userdata4_str();
  if (userdata4_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata4_str_ = new ::std::string;
  }
  userdata4_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata4_str() {
  set_has_userdata4_str();
  if (userdata4_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata4_str_ = new ::std::string;
  }
  return userdata4_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata4_str() {
  clear_has_userdata4_str();
  if (userdata4_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata4_str_;
    userdata4_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata4_str(::std::string* userdata4_str) {
  if (userdata4_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata4_str_;
  }
  if (userdata4_str) {
    set_has_userdata4_str();
    userdata4_str_ = userdata4_str;
  } else {
    clear_has_userdata4_str();
    userdata4_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata5_str = 27;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata5_str() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata5_str() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata5_str() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata5_str() {
  if (userdata5_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata5_str_->clear();
  }
  clear_has_userdata5_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata5_str() const {
  return *userdata5_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata5_str(const ::std::string& value) {
  set_has_userdata5_str();
  if (userdata5_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata5_str_ = new ::std::string;
  }
  userdata5_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata5_str(const char* value) {
  set_has_userdata5_str();
  if (userdata5_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata5_str_ = new ::std::string;
  }
  userdata5_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata5_str(const char* value, size_t size) {
  set_has_userdata5_str();
  if (userdata5_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata5_str_ = new ::std::string;
  }
  userdata5_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata5_str() {
  set_has_userdata5_str();
  if (userdata5_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata5_str_ = new ::std::string;
  }
  return userdata5_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata5_str() {
  clear_has_userdata5_str();
  if (userdata5_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata5_str_;
    userdata5_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata5_str(::std::string* userdata5_str) {
  if (userdata5_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata5_str_;
  }
  if (userdata5_str) {
    set_has_userdata5_str();
    userdata5_str_ = userdata5_str;
  } else {
    clear_has_userdata5_str();
    userdata5_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata6_str = 28;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata6_str() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata6_str() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata6_str() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata6_str() {
  if (userdata6_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata6_str_->clear();
  }
  clear_has_userdata6_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata6_str() const {
  return *userdata6_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata6_str(const ::std::string& value) {
  set_has_userdata6_str();
  if (userdata6_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata6_str_ = new ::std::string;
  }
  userdata6_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata6_str(const char* value) {
  set_has_userdata6_str();
  if (userdata6_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata6_str_ = new ::std::string;
  }
  userdata6_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata6_str(const char* value, size_t size) {
  set_has_userdata6_str();
  if (userdata6_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata6_str_ = new ::std::string;
  }
  userdata6_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata6_str() {
  set_has_userdata6_str();
  if (userdata6_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata6_str_ = new ::std::string;
  }
  return userdata6_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata6_str() {
  clear_has_userdata6_str();
  if (userdata6_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata6_str_;
    userdata6_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata6_str(::std::string* userdata6_str) {
  if (userdata6_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata6_str_;
  }
  if (userdata6_str) {
    set_has_userdata6_str();
    userdata6_str_ = userdata6_str;
  } else {
    clear_has_userdata6_str();
    userdata6_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata7_str = 29;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata7_str() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata7_str() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata7_str() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata7_str() {
  if (userdata7_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata7_str_->clear();
  }
  clear_has_userdata7_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata7_str() const {
  return *userdata7_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata7_str(const ::std::string& value) {
  set_has_userdata7_str();
  if (userdata7_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata7_str_ = new ::std::string;
  }
  userdata7_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata7_str(const char* value) {
  set_has_userdata7_str();
  if (userdata7_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata7_str_ = new ::std::string;
  }
  userdata7_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata7_str(const char* value, size_t size) {
  set_has_userdata7_str();
  if (userdata7_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata7_str_ = new ::std::string;
  }
  userdata7_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata7_str() {
  set_has_userdata7_str();
  if (userdata7_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata7_str_ = new ::std::string;
  }
  return userdata7_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata7_str() {
  clear_has_userdata7_str();
  if (userdata7_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata7_str_;
    userdata7_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata7_str(::std::string* userdata7_str) {
  if (userdata7_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata7_str_;
  }
  if (userdata7_str) {
    set_has_userdata7_str();
    userdata7_str_ = userdata7_str;
  } else {
    clear_has_userdata7_str();
    userdata7_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata8_str = 30;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata8_str() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata8_str() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata8_str() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata8_str() {
  if (userdata8_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata8_str_->clear();
  }
  clear_has_userdata8_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata8_str() const {
  return *userdata8_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata8_str(const ::std::string& value) {
  set_has_userdata8_str();
  if (userdata8_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata8_str_ = new ::std::string;
  }
  userdata8_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata8_str(const char* value) {
  set_has_userdata8_str();
  if (userdata8_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata8_str_ = new ::std::string;
  }
  userdata8_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata8_str(const char* value, size_t size) {
  set_has_userdata8_str();
  if (userdata8_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata8_str_ = new ::std::string;
  }
  userdata8_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata8_str() {
  set_has_userdata8_str();
  if (userdata8_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata8_str_ = new ::std::string;
  }
  return userdata8_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata8_str() {
  clear_has_userdata8_str();
  if (userdata8_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata8_str_;
    userdata8_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata8_str(::std::string* userdata8_str) {
  if (userdata8_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata8_str_;
  }
  if (userdata8_str) {
    set_has_userdata8_str();
    userdata8_str_ = userdata8_str;
  } else {
    clear_has_userdata8_str();
    userdata8_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userdata9_str = 31;
inline bool SIEMPbMessage_SIEMPbEvent::has_userdata9_str() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_userdata9_str() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_userdata9_str() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_userdata9_str() {
  if (userdata9_str_ != &::google::protobuf::internal::kEmptyString) {
    userdata9_str_->clear();
  }
  clear_has_userdata9_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::userdata9_str() const {
  return *userdata9_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata9_str(const ::std::string& value) {
  set_has_userdata9_str();
  if (userdata9_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata9_str_ = new ::std::string;
  }
  userdata9_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata9_str(const char* value) {
  set_has_userdata9_str();
  if (userdata9_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata9_str_ = new ::std::string;
  }
  userdata9_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_userdata9_str(const char* value, size_t size) {
  set_has_userdata9_str();
  if (userdata9_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata9_str_ = new ::std::string;
  }
  userdata9_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_userdata9_str() {
  set_has_userdata9_str();
  if (userdata9_str_ == &::google::protobuf::internal::kEmptyString) {
    userdata9_str_ = new ::std::string;
  }
  return userdata9_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_userdata9_str() {
  clear_has_userdata9_str();
  if (userdata9_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata9_str_;
    userdata9_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_userdata9_str(::std::string* userdata9_str) {
  if (userdata9_str_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata9_str_;
  }
  if (userdata9_str) {
    set_has_userdata9_str();
    userdata9_str_ = userdata9_str;
  } else {
    clear_has_userdata9_str();
    userdata9_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sensor_id_str = 32;
inline bool SIEMPbMessage_SIEMPbEvent::has_sensor_id_str() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_sensor_id_str() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_sensor_id_str() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_sensor_id_str() {
  if (sensor_id_str_ != &::google::protobuf::internal::kEmptyString) {
    sensor_id_str_->clear();
  }
  clear_has_sensor_id_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::sensor_id_str() const {
  return *sensor_id_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_sensor_id_str(const ::std::string& value) {
  set_has_sensor_id_str();
  if (sensor_id_str_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_str_ = new ::std::string;
  }
  sensor_id_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_sensor_id_str(const char* value) {
  set_has_sensor_id_str();
  if (sensor_id_str_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_str_ = new ::std::string;
  }
  sensor_id_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_sensor_id_str(const char* value, size_t size) {
  set_has_sensor_id_str();
  if (sensor_id_str_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_str_ = new ::std::string;
  }
  sensor_id_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_sensor_id_str() {
  set_has_sensor_id_str();
  if (sensor_id_str_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_str_ = new ::std::string;
  }
  return sensor_id_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_sensor_id_str() {
  clear_has_sensor_id_str();
  if (sensor_id_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensor_id_str_;
    sensor_id_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_sensor_id_str(::std::string* sensor_id_str) {
  if (sensor_id_str_ != &::google::protobuf::internal::kEmptyString) {
    delete sensor_id_str_;
  }
  if (sensor_id_str) {
    set_has_sensor_id_str();
    sensor_id_str_ = sensor_id_str;
  } else {
    clear_has_sensor_id_str();
    sensor_id_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string binary_data_str = 33;
inline bool SIEMPbMessage_SIEMPbEvent::has_binary_data_str() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void SIEMPbMessage_SIEMPbEvent::set_has_binary_data_str() {
  _has_bits_[1] |= 0x00000001u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_has_binary_data_str() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void SIEMPbMessage_SIEMPbEvent::clear_binary_data_str() {
  if (binary_data_str_ != &::google::protobuf::internal::kEmptyString) {
    binary_data_str_->clear();
  }
  clear_has_binary_data_str();
}
inline const ::std::string& SIEMPbMessage_SIEMPbEvent::binary_data_str() const {
  return *binary_data_str_;
}
inline void SIEMPbMessage_SIEMPbEvent::set_binary_data_str(const ::std::string& value) {
  set_has_binary_data_str();
  if (binary_data_str_ == &::google::protobuf::internal::kEmptyString) {
    binary_data_str_ = new ::std::string;
  }
  binary_data_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_binary_data_str(const char* value) {
  set_has_binary_data_str();
  if (binary_data_str_ == &::google::protobuf::internal::kEmptyString) {
    binary_data_str_ = new ::std::string;
  }
  binary_data_str_->assign(value);
}
inline void SIEMPbMessage_SIEMPbEvent::set_binary_data_str(const char* value, size_t size) {
  set_has_binary_data_str();
  if (binary_data_str_ == &::google::protobuf::internal::kEmptyString) {
    binary_data_str_ = new ::std::string;
  }
  binary_data_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::mutable_binary_data_str() {
  set_has_binary_data_str();
  if (binary_data_str_ == &::google::protobuf::internal::kEmptyString) {
    binary_data_str_ = new ::std::string;
  }
  return binary_data_str_;
}
inline ::std::string* SIEMPbMessage_SIEMPbEvent::release_binary_data_str() {
  clear_has_binary_data_str();
  if (binary_data_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = binary_data_str_;
    binary_data_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIEMPbMessage_SIEMPbEvent::set_allocated_binary_data_str(::std::string* binary_data_str) {
  if (binary_data_str_ != &::google::protobuf::internal::kEmptyString) {
    delete binary_data_str_;
  }
  if (binary_data_str) {
    set_has_binary_data_str();
    binary_data_str_ = binary_data_str;
  } else {
    clear_has_binary_data_str();
    binary_data_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SIEMPbMessage

// optional .SIEM.SIEMPbMessage.SIEMPbEvent siem_event = 1;
inline bool SIEMPbMessage::has_siem_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SIEMPbMessage::set_has_siem_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SIEMPbMessage::clear_has_siem_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SIEMPbMessage::clear_siem_event() {
  if (siem_event_ != NULL) siem_event_->::SIEM::SIEMPbMessage_SIEMPbEvent::Clear();
  clear_has_siem_event();
}
inline const ::SIEM::SIEMPbMessage_SIEMPbEvent& SIEMPbMessage::siem_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return siem_event_ != NULL ? *siem_event_ : *default_instance().siem_event_;
#else
  return siem_event_ != NULL ? *siem_event_ : *default_instance_->siem_event_;
#endif
}
inline ::SIEM::SIEMPbMessage_SIEMPbEvent* SIEMPbMessage::mutable_siem_event() {
  set_has_siem_event();
  if (siem_event_ == NULL) siem_event_ = new ::SIEM::SIEMPbMessage_SIEMPbEvent;
  return siem_event_;
}
inline ::SIEM::SIEMPbMessage_SIEMPbEvent* SIEMPbMessage::release_siem_event() {
  clear_has_siem_event();
  ::SIEM::SIEMPbMessage_SIEMPbEvent* temp = siem_event_;
  siem_event_ = NULL;
  return temp;
}
inline void SIEMPbMessage::set_allocated_siem_event(::SIEM::SIEMPbMessage_SIEMPbEvent* siem_event) {
  delete siem_event_;
  siem_event_ = siem_event;
  if (siem_event) {
    set_has_siem_event();
  } else {
    clear_has_siem_event();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SIEM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SIEMMessage_2eproto__INCLUDED
